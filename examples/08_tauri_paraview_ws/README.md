# Tauri + WebSocket

This example leverages tauri for just its WebView and lets trame act as the full HTTP server by serving its content over HTTP and WebSocket. Additionally, this example also demonstrates using ParaView for rendering and computation.

## Tauri project

Since Tauri is written in Rust, let's get setup with its dev environment.

```bash
# Install rust
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# Enable rust within shell
. "$HOME/.cargo/env"

# Install tauri-cli
cargo install tauri-cli
```

Then, the infrastructure (./src-tauri) was generated by running the following commands. 

__Caution__: No need to redo it since we committed the generated structure to the repo.

```bash
$ cargo tauri init

✔ What is your app name? · Cone
✔ What should the window title be? · Cone
✔ Where are your web assets (HTML/CSS/JS) located, relative to the "<current dir>/src-tauri/tauri.conf.json" file that will be created? · ./www
✔ What is the url of your dev server? · ./www
✔ What is your frontend dev command? · 
✔ What is your frontend build command? · 
```

From the default content, we edited the following set of files:

- `./src-tauri/src/main.rs`: Generic main application designed for trame which can remain the same regardless of your application.
- `./src-tauri/sidecar/*`: OS specific launcher for a trame server. The mac and linux version are just plain bash scripts while the Windows one is a simple compiled C++ application that forward the args to the actual trame python executable generated by PyInstaller. Those can be re-used as-is for any trame app. A departure from the other examples, this app uses `pvpython` to launch the app instead of the packaged binary.
- `./src-tauri/www/*`: Basic content for splashscreen and temporary main window content before we apply a redirect. Those are static and could be adjusted by adding your own image as splashscreen.
- `./src-tauri/icons`: Remove default ones (`rm -rf ./src-tauri/icons`)
- `./src-tauri/Cargo.toml`: Added new dependencies and required feature.
- `./src-tauri/tauri.conf.json`: Edited the following sections
    - tauri > allowlist: + shell/sidecar
    - tauri > bundle > externalBin : ["sidecar/trame"]
    - tauri > bundle > identifier  : "trame.cone"
    - tauri > bundle > resources   : ["server"] # pyinstaller generated app
    - tauri > bundle > targets     : ["appimage", "nsis", "msi", "app", "dmg"]
    - tauri > security > csp       : "default-src 'self' 'unsafe-inline' ws: localhost; script-src 'unsafe-eval' 'self';"
    - tauri > windows              : main-not-visible + splashscreen

## Copy application to container

Since the app uses `pvpython` to launch the application, the python executables need to be copied over to the server directory for it to be bundled

```bash
cp cone.py src-tauri/server
```

## Trame example

We use a simple cone example since it does not have any complex python dependency. Since we're bundling a `ParaView` based application, and `ParaView` not being `pip` installable, this example uses `conda`


```bash
conda create --name tauri -c conda-forge python=3.13
conda activate tauri
pip install trame trame-vtk trame-vuetify pyinstaller
conda install paraview=5.13.3
```

Build bundle for tauri inside `./src-tauri/server/*` while skipping the web content.

```bash
python -m PyInstaller 
    --clean --noconfirm \
    --distpath src-tauri \
    --name server --hidden-import pkgutil \
    --collect-all paraview
    cone.py
```

Generate webcontent for tauri to bundle

```bash
python -m trame.tools.www --output ./src-tauri/www
```

## Tauri bundle

In order to build and bundle the application, just run

```bash
# Generate icon for application using ./app-icon.png
cargo tauri icon

# Generate application
cargo tauri build
```

## Running application

### Linux and macOS
```bash
open ./src-tauri/target/release/bundle/macos/Cone.app
```
